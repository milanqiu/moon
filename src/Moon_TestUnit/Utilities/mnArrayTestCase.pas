unit mnArrayTestCase;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit
  being tested.

}

interface

uses
  TestFramework;

type
  TmnArrayTestCase = class(TTestCase)
  strict private
  public
    procedure SetUp; override;
    procedure TearDown; override;
  published
    procedure testArrayCompare;
    procedure testArrayCopy;
    procedure testArrayAppend;
    procedure testArrayInsert;
    procedure testArrayDelete;
    procedure testArrayShuffle;
    procedure testInSeries;
    procedure testIndexOfSeries;
    procedure testVALength;
    procedure testVAContainRangeDim2;
    procedure testCheckVADim1;
    procedure testCheckVADim2;
    procedure testCheckVAContainRangeDim2;
    procedure testVAToArray;
    procedure testArrayToVA;
    procedure testVAToArrayDim2;
    procedure testArrayToVADim2;
    procedure testPartVAToArrayDim2;
    procedure testPartArrayToVADim2;
    procedure testBase1VAToArrayDim2;
    procedure testBase2VAToArrayDim2;
    procedure testBase1ArrayToVADim2;
    procedure testBase2ArrayToVADim2;
  end;

implementation

uses mnArray, UTestConsts, mnSystem, mnDebug, mnResStrsU, SysUtils, mnMath, Variants;

{ TmnArrayTestCase }

procedure TmnArrayTestCase.SetUp;
begin
end;

procedure TmnArrayTestCase.TearDown;
begin
end;

procedure TmnArrayTestCase.testArrayCompare;
var
  VarArrA, VarArrB, VarArrC: array of Variant;
  IntArrA, IntArrB, IntArrC: array of Integer;
  PtrArrA, PtrArrB, PtrArrC: array of Pointer;
begin
  SetLength(VarArrA, 3);
  VarArrA[0] := Var_0;
  VarArrA[1] := Var_1;
  VarArrA[2] := Var_2;
  SetLength(VarArrB, 3);
  VarArrB[0] := VarArrA[0]; // string, so must ensure the address is equal
  VarArrB[1] := Var_1;
  VarArrB[2] := Var_2;
  VarArrC := VarArrB;
  Check(mnArrayCompare(VarArrA, VarArrB, SizeOf(Variant)));
  VarArrC[1] := Var_3;
  CheckFalse(mnArrayCompare(VarArrA, VarArrB, SizeOf(Variant)));
  SetLength(VarArrB, 1);
  CheckFalse(mnArrayCompare(VarArrA, VarArrB, SizeOf(Variant)));

  SetLength(IntArrA, 3);
  IntArrA[0] := Int_0;
  IntArrA[1] := Int_1;
  IntArrA[2] := Int_2;
  SetLength(IntArrB, 3);
  IntArrB[0] := Int_0;
  IntArrB[1] := Int_1;
  IntArrB[2] := Int_2;
  IntArrC := IntArrB;
  Check(mnArrayCompare(IntArrA, IntArrB, SizeOf(Integer)));
  IntArrC[1] := Int_3;
  CheckFalse(mnArrayCompare(IntArrA, IntArrB, SizeOf(Integer)));
  SetLength(IntArrB, 1);
  CheckFalse(mnArrayCompare(IntArrA, IntArrB, SizeOf(Integer)));

  SetLength(PtrArrA, 3);
  PtrArrA[0] := mnNewIntPointer(Int_0);
  PtrArrA[1] := mnNewIntPointer(Int_1);
  PtrArrA[2] := mnNewIntPointer(Int_2);
  SetLength(PtrArrB, 3);
  PtrArrB[0] := PtrArrA[0]; // pointer, so must ensure the address is equal
  PtrArrB[1] := PtrArrA[1]; // pointer, so must ensure the address is equal
  PtrArrB[2] := PtrArrA[2]; // pointer, so must ensure the address is equal
  PtrArrC := PtrArrB;
  Check(mnArrayCompare(PtrArrA, PtrArrB, SizeOf(Pointer)));
  PtrArrC[1] := mnNewIntPointer(Int_1);
  CheckFalse(mnArrayCompare(PtrArrA, PtrArrB, SizeOf(Pointer)));
  mnFreePointer(PtrArrB[1]);
  SetLength(PtrArrB, 1);
  CheckFalse(mnArrayCompare(PtrArrA, PtrArrB, SizeOf(Pointer)));
  mnFreePointer(PtrArrA[0]);
  mnFreePointer(PtrArrA[1]);
  mnFreePointer(PtrArrA[2]);
end;

procedure TmnArrayTestCase.testArrayCopy;
var
  SrcVarArr, DstVarArr: array of Variant;
  SrcIntArr, DstIntArr: array of Integer;
begin
  SetLength(SrcVarArr, 3);
  SrcVarArr[0] := Var_0;
  SrcVarArr[1] := Var_1;
  SrcVarArr[2] := Var_2;
  SetLength(DstVarArr, 2);
  DstVarArr[0] := Var_3;
  DstVarArr[1] := Var_4;
  mnArrayCopy(SrcVarArr, DstVarArr, SizeOf(Variant), 2, 1, 2);
  CheckEquals(Length(SrcVarArr), 3);
  Check(SrcVarArr[0] = Var_0);
  Check(SrcVarArr[1] = Var_1);
  Check(SrcVarArr[2] = Var_2);
  CheckEquals(Length(DstVarArr), 2);
  Check(DstVarArr[0] = Var_3);
  Check(DstVarArr[1] = Var_2);
  try
    mnArrayCopy(SrcVarArr, DstVarArr, SizeOf(Variant), 3, 1, 1);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayCopySrcIndexError, [3, Length(SrcVarArr)]));
  end;

  SetLength(SrcIntArr, 3);
  SrcIntArr[0] := Int_0;
  SrcIntArr[1] := Int_1;
  SrcIntArr[2] := Int_2;
  SetLength(DstIntArr, 2);
  DstIntArr[0] := Int_3;
  DstIntArr[1] := Int_4;
  mnArrayCopy(SrcIntArr, DstIntArr, SizeOf(Integer), 2, 1, 2);
  CheckEquals(Length(SrcIntArr), 3);
  CheckEquals(SrcIntArr[0], Int_0);
  CheckEquals(SrcIntArr[1], Int_1);
  CheckEquals(SrcIntArr[2], Int_2);
  CheckEquals(Length(DstIntArr), 2);
  CheckEquals(DstIntArr[0], Int_3);
  CheckEquals(DstIntArr[1], Int_2);
  try
    mnArrayCopy(SrcIntArr, DstIntArr, SizeOf(Integer), 2, 2, 1);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayCopyDstIndexError, [2, Length(DstIntArr)]));
  end;
end;

procedure TmnArrayTestCase.testArrayAppend;
var
  VarArr: array of Variant;
  IntArr: array of Integer;
begin
  SetLength(VarArr, 2);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  mnArrayAppend(VarArr, SizeOf(Variant), 2);
  CheckEquals(Length(VarArr), 4);
  Check(VarArr[0] = Var_0);
  Check(VarArr[1] = Var_1);
  Check(VarArr[2] = 0);
  Check(VarArr[3] = 0);

  SetLength(IntArr, 2);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  mnArrayAppend(IntArr, SizeOf(Integer));
  CheckEquals(Length(IntArr), 3);
  CheckEquals(IntArr[0], Int_0);
  CheckEquals(IntArr[1], Int_1);
  CheckEquals(IntArr[2], 0);
end;

procedure TmnArrayTestCase.testArrayInsert;
var
  VarArr: array of Variant;
  IntArr: array of Integer;
begin
  SetLength(VarArr, 2);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  mnArrayInsert(VarArr, SizeOf(Variant), 1, 2);
  CheckEquals(Length(VarArr), 4);
  Check(VarArr[0] = Var_0);
  Check(VarArr[1] = 0);
  Check(VarArr[2] = 0);
  Check(VarArr[3] = Var_1);

  SetLength(IntArr, 2);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  mnArrayInsert(IntArr, SizeOf(Integer), 1);
  CheckEquals(Length(IntArr), 3);
  CheckEquals(IntArr[0], Int_0);
  CheckEquals(IntArr[1], 0);
  CheckEquals(IntArr[2], Int_1);

  try
    mnArrayInsert(VarArr, SizeOf(Variant), 5);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayInsertIndexError, [5, Length(VarArr)]));
  end;
end;

procedure TmnArrayTestCase.testArrayDelete;
var
  VarArr: array of Variant;
  IntArr: array of Integer;
begin
  SetLength(VarArr, 4);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  VarArr[2] := Var_2;
  VarArr[3] := Var_3;
  mnArrayDelete(VarArr, SizeOf(Variant), 1, 2);
  CheckEquals(Length(VarArr), 2);
  Check(VarArr[0] = Var_0);
  Check(VarArr[1] = Var_3);

  SetLength(IntArr, 4);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  IntArr[2] := Int_2;
  IntArr[3] := Int_3;
  mnArrayDelete(IntArr, SizeOf(Integer), 1);
  CheckEquals(Length(IntArr), 3);
  CheckEquals(IntArr[0], Int_0);
  CheckEquals(IntArr[1], Int_2);
  CheckEquals(IntArr[2], Int_3);

  try
    mnArrayDelete(VarArr, SizeOf(Variant), 2);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayDeleteIndexError, [2, Length(VarArr)]));
  end;
end;

procedure TmnArrayTestCase.testArrayShuffle;
var
  VarArr: array of Variant;
  IntArr: array of Integer;
  i: Integer;
begin
  for i := 1 to 1000 do
  begin
    SetLength(VarArr, 4);
    VarArr[0] := Var_0;
    VarArr[1] := Var_1;
    VarArr[2] := Var_2;
    VarArr[3] := Var_3;

    mnArrayShuffle(VarArr, SizeOf(Variant), 1, 2);

    Check(VarArr[0] = Var_0);
    Check(VarArr[3] = Var_3);
    Check(((VarArr[1] = Var_1) and (VarArr[2] = Var_2))
       or ((VarArr[1] = Var_2) and (VarArr[2] = Var_1)));


    SetLength(IntArr, 4);
    IntArr[0] := Int_0;
    IntArr[1] := Int_1;
    IntArr[2] := Int_2;
    IntArr[3] := Int_3;

    mnArrayShuffle(IntArr, SizeOf(Integer), 1, 3);

    Check(IntArr[0] = Int_0);
    Check(((IntArr[1] = Int_1) and (IntArr[2] = Int_2) and (IntArr[3] = Int_3))
       or ((IntArr[1] = Int_1) and (IntArr[2] = Int_3) and (IntArr[3] = Int_2))
       or ((IntArr[1] = Int_2) and (IntArr[2] = Int_1) and (IntArr[3] = Int_3))
       or ((IntArr[1] = Int_2) and (IntArr[2] = Int_3) and (IntArr[3] = Int_1))
       or ((IntArr[1] = Int_3) and (IntArr[2] = Int_1) and (IntArr[3] = Int_2))
       or ((IntArr[1] = Int_3) and (IntArr[2] = Int_2) and (IntArr[3] = Int_1)));
  end;
end;

procedure TmnArrayTestCase.testInSeries;
var
  StrArr: array of string;
  IntArr: array of Integer;
  FloatArr: array of Extended;
  DTArr: array of TDateTime;
  CurrArr: array of Currency;
begin
  SetLength(StrArr, 3);
  StrArr[0] := Str_0;
  StrArr[1] := Str_1;
  StrArr[2] := Str_2;
  Check(mnInStrs(Str_0, StrArr));
  Check(mnInStrs(Str_1, StrArr));
  Check(mnInStrs(Str_2, StrArr));
  CheckFalse(mnInStrs(Str_3, StrArr));

  SetLength(IntArr, 3);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  IntArr[2] := Int_2;
  Check(mnInInts(Int_0, IntArr));
  Check(mnInInts(Int_1, IntArr));
  Check(mnInInts(Int_2, IntArr));
  CheckFalse(mnInInts(Int_3, IntArr));

  SetLength(FloatArr, 3);
  FloatArr[0] := Float_0;
  FloatArr[1] := Float_1;
  FloatArr[2] := Float_2;
  Check(mnInFloats(Float_0, FloatArr));
  Check(mnInFloats(Float_1, FloatArr));
  Check(mnInFloats(Float_2, FloatArr));
  CheckFalse(mnInFloats(Float_3, FloatArr));

  SetLength(DTArr, 3);
  DTArr[0] := DT_0;
  DTArr[1] := DT_1;
  DTArr[2] := DT_2;
  Check(mnInDTs(DT_0, DTArr));
  Check(mnInDTs(DT_1, DTArr));
  Check(mnInDTs(DT_2, DTArr));
  CheckFalse(mnInDTs(DT_3, DTArr));

  SetLength(CurrArr, 3);
  CurrArr[0] := Curr_0;
  CurrArr[1] := Curr_1;
  CurrArr[2] := Curr_2;
  Check(mnInCurrs(Curr_0, CurrArr));
  Check(mnInCurrs(Curr_1, CurrArr));
  Check(mnInCurrs(Curr_2, CurrArr));
  CheckFalse(mnInCurrs(Curr_3, CurrArr));
end;

procedure TmnArrayTestCase.testIndexOfSeries;
var
  StrArr: array of string;
  IntArr: array of Integer;
  FloatArr: array of Extended;
  DTArr: array of TDateTime;
  CurrArr: array of Currency;
begin
  SetLength(StrArr, 3);
  StrArr[0] := Str_0;
  StrArr[1] := Str_1;
  StrArr[2] := Str_2;
  CheckEquals(mnIndexOfStrs(Str_0, StrArr), 0);
  CheckEquals(mnIndexOfStrs(Str_1, StrArr), 1);
  CheckEquals(mnIndexOfStrs(Str_2, StrArr), 2);
  CheckEquals(mnIndexOfStrs(Str_3, StrArr), -1);

  SetLength(IntArr, 3);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  IntArr[2] := Int_2;
  CheckEquals(mnIndexOfInts(Int_0, IntArr), 0);
  CheckEquals(mnIndexOfInts(Int_1, IntArr), 1);
  CheckEquals(mnIndexOfInts(Int_2, IntArr), 2);
  CheckEquals(mnIndexOfInts(Int_3, IntArr), -1);

  SetLength(FloatArr, 3);
  FloatArr[0] := Float_0;
  FloatArr[1] := Float_1;
  FloatArr[2] := Float_2;
  CheckEquals(mnIndexOfFloats(Float_0, FloatArr), 0);
  CheckEquals(mnIndexOfFloats(Float_1, FloatArr), 1);
  CheckEquals(mnIndexOfFloats(Float_2, FloatArr), 2);
  CheckEquals(mnIndexOfFloats(Float_3, FloatArr), -1);

  SetLength(DTArr, 3);
  DTArr[0] := DT_0;
  DTArr[1] := DT_1;
  DTArr[2] := DT_2;
  CheckEquals(mnIndexOfDTs(DT_0, DTArr), 0);
  CheckEquals(mnIndexOfDTs(DT_1, DTArr), 1);
  CheckEquals(mnIndexOfDTs(DT_2, DTArr), 2);
  CheckEquals(mnIndexOfDTs(DT_3, DTArr), -1);

  SetLength(CurrArr, 3);
  CurrArr[0] := Curr_0;
  CurrArr[1] := Curr_1;
  CurrArr[2] := Curr_2;
  CheckEquals(mnIndexOfCurrs(Curr_0, CurrArr), 0);
  CheckEquals(mnIndexOfCurrs(Curr_1, CurrArr), 1);
  CheckEquals(mnIndexOfCurrs(Curr_2, CurrArr), 2);
  CheckEquals(mnIndexOfCurrs(Curr_3, CurrArr), -1);
end;

procedure TmnArrayTestCase.testVALength;
var
  VA: Variant;
begin
  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  CheckEquals(mnVALength(VA, 1), 10);
  CheckEquals(mnVALength(VA, 2), 22);
end;

procedure TmnArrayTestCase.testVAContainRangeDim2;
var
  VA: Variant;
begin
  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  Check(mnVAContainRangeDim2(VA, 1, 10, 8, 29));
  CheckFalse(mnVAContainRangeDim2(VA, 0, 10, 8, 29));
  CheckFalse(mnVAContainRangeDim2(VA, 1, 11, 8, 29));
  CheckFalse(mnVAContainRangeDim2(VA, 1, 10, 7, 29));
  CheckFalse(mnVAContainRangeDim2(VA, 1, 10, 8, 30));
end;

procedure TmnArrayTestCase.testCheckVADim1;
var
  VA: Variant;
begin
  VA := VarArrayCreate([8, 29], varVariant);
  mnCheckVADim1(VA);

  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  try
    mnCheckVADim1(VA);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, SVANotDim1);
  end;
end;

procedure TmnArrayTestCase.testCheckVADim2;
var
  VA: Variant;
begin
  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  mnCheckVADim2(VA);

  VA := VarArrayCreate([8, 29], varVariant);
  try
    mnCheckVADim2(VA);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, SVANotDim2);
  end;
end;

procedure TmnArrayTestCase.testCheckVAContainRangeDim2;
var
  VA: Variant;
begin
  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  mnCheckVAContainRangeDim2(VA, 1, 10, 8, 29);

  try
    mnCheckVAContainRangeDim2(VA, 1, 11, 8, 29);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SVANotContainRangeDim2, [1, 10, 8, 29, 1, 11, 8, 29]));
  end;
end;

procedure TmnArrayTestCase.testVAToArray;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
  IntArr: array of Integer;
begin
  // mnVAToArray overload form 1
  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  try
    mnVAToArray(VA, VarArr);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, SVANotDim1);
  end;

  VA := VarArrayOf([Var_0, Var_1, Var_2]);
  SetLength(VarArr, 2);
  try
    mnVAToArray(VA, VarArr);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayTooShort, [2, 3]));
  end;

  SetLength(VarArr, 3);
  mnVAToArray(VA, VarArr);
  Check(VarArr[0] = Var_0);
  Check(VarArr[1] = Var_1);
  Check(VarArr[2] = Var_2);

  // mnVAToArray overload form 2
  VA := VarArrayOf([Str_0, Str_1, Str_2]);
  SetLength(StrArr, 3);
  mnVAToArray(VA, StrArr);
  Check(StrArr[0] = Str_0);
  Check(StrArr[1] = Str_1);
  Check(StrArr[2] = Str_2);

  // mnVAToArray overload form 3
  VA := VarArrayOf([Int_0, Int_1, Int_2]);
  SetLength(IntArr, 3);
  mnVAToArray(VA, IntArr);
  Check(IntArr[0] = Int_0);
  Check(IntArr[1] = Int_1);
  Check(IntArr[2] = Int_2);

  // overload form 4, 5 and 6 are ignored
end;

procedure TmnArrayTestCase.testArrayToVA;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
  IntArr: array of Integer;
begin
  // mnArrayToVA overload form 1
  SetLength(VarArr, 3);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  VarArr[2] := Var_2;

  VA := mnArrayToVA(VarArr);
  CheckEquals(VarArrayDimCount(VA), 1);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 3);
  Check(VarArrayGet(VA, [1]) = Var_0);
  Check(VarArrayGet(VA, [2]) = Var_1);
  Check(VarArrayGet(VA, [3]) = Var_2);

  // mnArrayToVA overload form 2
  SetLength(StrArr, 3);
  StrArr[0] := Str_0;
  StrArr[1] := Str_1;
  StrArr[2] := Str_2;

  VA := mnArrayToVA(StrArr);
  CheckEquals(VarArrayDimCount(VA), 1);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 3);
  Check(VarArrayGet(VA, [1]) = Str_0);
  Check(VarArrayGet(VA, [2]) = Str_1);
  Check(VarArrayGet(VA, [3]) = Str_2);

  // mnArrayToVA overload form 3
  SetLength(IntArr, 3);
  IntArr[0] := Int_0;
  IntArr[1] := Int_1;
  IntArr[2] := Int_2;

  VA := mnArrayToVA(IntArr);
  CheckEquals(VarArrayDimCount(VA), 1);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 3);
  Check(VarArrayGet(VA, [1]) = Int_0);
  Check(VarArrayGet(VA, [2]) = Int_1);
  Check(VarArrayGet(VA, [3]) = Int_2);

  // overload form 4, 5 and 6 are ignored
end;

procedure TmnArrayTestCase.testVAToArrayDim2;
var
  VA: Variant;
  VarArr: mnTVarArrayDim2;
  StrArr: mnTStrArrayDim2;
begin
  // mnVAToArrayDim2 overload form 1
  VA := VarArrayCreate([8, 29], varVariant);
  try
    mnVAToArrayDim2(VA, VarArr);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, SVANotDim2);
  end;

  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  SetLength(VarArr, 9, 22);
  try
    mnVAToArrayDim2(VA, VarArr);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayTooShort, [9, 10]));
  end;

  VA := VarArrayCreate([2, 5, 8, 9], varVariant);
  VarArrayPut(VA, Var_0, [2, 8]);
  VarArrayPut(VA, Var_1, [2, 9]);
  VarArrayPut(VA, Var_2, [3, 8]);
  VarArrayPut(VA, Var_3, [3, 9]);
  VarArrayPut(VA, Var_4, [4, 8]);
  VarArrayPut(VA, Var_0, [4, 9]);
  VarArrayPut(VA, Var_1, [5, 8]);
  VarArrayPut(VA, Var_2, [5, 9]);
  SetLength(VarArr, 4, 2);
  mnVAToArrayDim2(VA, VarArr);
  Check(VarArr[0][0] = Var_0);
  Check(VarArr[0][1] = Var_1);
  Check(VarArr[1][0] = Var_2);
  Check(VarArr[1][1] = Var_3);
  Check(VarArr[2][0] = Var_4);
  Check(VarArr[2][1] = Var_0);
  Check(VarArr[3][0] = Var_1);
  Check(VarArr[3][1] = Var_2);

  // mnVAToArrayDim2_A overload form 1
  SetLength(VarArr, 0, 0);
  mnVAToArrayDim2_A(VA, VarArr);
  CheckEquals(Length(VarArr), 4);
  CheckEquals(Length(VarArr[0]), 2);
  Check(VarArr[0][0] = Var_0);
  Check(VarArr[0][1] = Var_1);
  Check(VarArr[1][0] = Var_2);
  Check(VarArr[1][1] = Var_3);
  Check(VarArr[2][0] = Var_4);
  Check(VarArr[2][1] = Var_0);
  Check(VarArr[3][0] = Var_1);
  Check(VarArr[3][1] = Var_2);

  // mnVAToArrayDim2 overload form 2
  SetLength(StrArr, 4, 2);
  mnVAToArrayDim2(VA, StrArr);
  Check(StrArr[0][0] = VarToStr(Var_0));
  Check(StrArr[0][1] = VarToStr(Var_1));
  Check(StrArr[1][0] = VarToStr(Var_2));
  Check(StrArr[1][1] = VarToStr(Var_3));
  Check(StrArr[2][0] = VarToStr(Var_4));
  Check(StrArr[2][1] = VarToStr(Var_0));
  Check(StrArr[3][0] = VarToStr(Var_1));
  Check(StrArr[3][1] = VarToStr(Var_2));

  // mnVAToArrayDim2_A overload form 2
  SetLength(StrArr, 0, 0);
  mnVAToArrayDim2_A(VA, StrArr);
  CheckEquals(Length(StrArr), 4);
  CheckEquals(Length(StrArr[0]), 2);
  Check(StrArr[0][0] = VarToStr(Var_0));
  Check(StrArr[0][1] = VarToStr(Var_1));
  Check(StrArr[1][0] = VarToStr(Var_2));
  Check(StrArr[1][1] = VarToStr(Var_3));
  Check(StrArr[2][0] = VarToStr(Var_4));
  Check(StrArr[2][1] = VarToStr(Var_0));
  Check(StrArr[3][0] = VarToStr(Var_1));
  Check(StrArr[3][1] = VarToStr(Var_2));

  // overload form 3 is ignored
end;

procedure TmnArrayTestCase.testArrayToVADim2;
var
  VA: Variant;
  VarArr: mnTVarArrayDim2;
  StrArr: mnTStrArrayDim2;
begin
  // mnArrayToVADim2 overload form 1
  SetLength(VarArr, 4, 2);
  VarArr[0][0] := Var_0;
  VarArr[0][1] := Var_1;
  VarArr[1][0] := Var_2;
  VarArr[1][1] := Var_3;
  VarArr[2][0] := Var_4;
  VarArr[2][1] := Var_0;
  VarArr[3][0] := Var_1;
  VarArr[3][1] := Var_2;

  VA := mnArrayToVADim2(VarArr);
  CheckEquals(VarArrayDimCount(VA), 2);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 4);
  CheckEquals(VarArrayLowBound(VA, 2), 1);
  CheckEquals(VarArrayHighBound(VA, 2), 2);
  Check(VarArrayGet(VA, [1, 1]) = Var_0);
  Check(VarArrayGet(VA, [1, 2]) = Var_1);
  Check(VarArrayGet(VA, [2, 1]) = Var_2);
  Check(VarArrayGet(VA, [2, 2]) = Var_3);
  Check(VarArrayGet(VA, [3, 1]) = Var_4);
  Check(VarArrayGet(VA, [3, 2]) = Var_0);
  Check(VarArrayGet(VA, [4, 1]) = Var_1);
  Check(VarArrayGet(VA, [4, 2]) = Var_2);

  // mnArrayToVADim2 overload form 2
  SetLength(StrArr, 4, 2);
  StrArr[0][0] := Str_0;
  StrArr[0][1] := Str_1;
  StrArr[1][0] := Str_2;
  StrArr[1][1] := Str_3;
  StrArr[2][0] := Str_4;
  StrArr[2][1] := Str_0;
  StrArr[3][0] := Str_1;
  StrArr[3][1] := Str_2;

  VA := mnArrayToVADim2(StrArr);
  CheckEquals(VarArrayDimCount(VA), 2);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 4);
  CheckEquals(VarArrayLowBound(VA, 2), 1);
  CheckEquals(VarArrayHighBound(VA, 2), 2);
  Check(VarArrayGet(VA, [1, 1]) = Str_0);
  Check(VarArrayGet(VA, [1, 2]) = Str_1);
  Check(VarArrayGet(VA, [2, 1]) = Str_2);
  Check(VarArrayGet(VA, [2, 2]) = Str_3);
  Check(VarArrayGet(VA, [3, 1]) = Str_4);
  Check(VarArrayGet(VA, [3, 2]) = Str_0);
  Check(VarArrayGet(VA, [4, 1]) = Str_1);
  Check(VarArrayGet(VA, [4, 2]) = Str_2);

  // overload form 3 is ignored
end;

procedure TmnArrayTestCase.testPartVAToArrayDim2;
var
  VA: Variant;
  VarArr: mnTVarArrayDim2;
  StrArr: mnTStrArrayDim2;
begin
  // mnPartVAToArrayDim2 overload form 1
  VA := VarArrayCreate([8, 29], varVariant);
  try
    mnPartVAToArrayDim2(VA, VarArr, 3, 4, 5, 6);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, SVANotDim2);
  end;

  VA := VarArrayCreate([1, 10, 8, 29], varVariant);
  SetLength(VarArr, 1, 2);
  try
    mnPartVAToArrayDim2(VA, VarArr, 3, 4, 9, 10);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SArrayTooShort, [1, 2]));
  end;

  VA := VarArrayCreate([2, 5, 8, 9], varVariant);
  VarArrayPut(VA, Var_0, [2, 8]);
  VarArrayPut(VA, Var_1, [2, 9]);
  VarArrayPut(VA, Var_2, [3, 8]);
  VarArrayPut(VA, Var_3, [3, 9]);
  VarArrayPut(VA, Var_4, [4, 8]);
  VarArrayPut(VA, Var_0, [4, 9]);
  VarArrayPut(VA, Var_1, [5, 8]);
  VarArrayPut(VA, Var_2, [5, 9]);
  SetLength(VarArr, 2, 1);
  mnPartVAToArrayDim2(VA, VarArr, 3, 4, 8, 8);
  Check(VarArr[0][0] = Var_2);
  Check(VarArr[1][0] = Var_4);

  // mnPartVAToArrayDim2_A overload form 1
  SetLength(VarArr, 0, 0);
  mnPartVAToArrayDim2_A(VA, VarArr, 3, 4, 8, 8);
  CheckEquals(Length(VarArr), 2);
  CheckEquals(Length(VarArr[0]), 1);
  Check(VarArr[0][0] = Var_2);
  Check(VarArr[1][0] = Var_4);

  // mnPartVAToArrayDim2 overload form 2
  SetLength(StrArr, 2, 1);
  mnPartVAToArrayDim2(VA, StrArr, 3, 4, 8, 8);
  Check(StrArr[0][0] = VarToStr(Var_2));
  Check(StrArr[1][0] = VarToStr(Var_4));

  // mnPartVAToArrayDim2_A overload form 2
  SetLength(StrArr, 0, 0);
  mnPartVAToArrayDim2_A(VA, StrArr, 3, 4, 8, 8);
  CheckEquals(Length(StrArr), 2);
  CheckEquals(Length(StrArr[0]), 1);
  Check(StrArr[0][0] = VarToStr(Var_2));
  Check(StrArr[1][0] = VarToStr(Var_4));

  // overload form 3 is ignored
end;

procedure TmnArrayTestCase.testPartArrayToVADim2;
var
  VA: Variant;
  VarArr: mnTVarArrayDim2;
  StrArr: mnTStrArrayDim2;
begin
  // mnPartArrayToVADim2 overload form 1
  SetLength(VarArr, 4, 2);
  VarArr[0][0] := Var_0;
  VarArr[0][1] := Var_1;
  VarArr[1][0] := Var_2;
  VarArr[1][1] := Var_3;
  VarArr[2][0] := Var_4;
  VarArr[2][1] := Var_0;
  VarArr[3][0] := Var_1;
  VarArr[3][1] := Var_2;

  VA := VarArrayCreate([1, 5, 1, 6], varVariant);
  try
    mnPartArrayToVADim2(VarArr, VA, 3, 5);
    mnNeverGoesHere;
  except
    on E: Exception do CheckEquals(E.Message, Format(SVANotContainRangeDim2, [1, 5, 1, 6, 3, 6, 5, 6]));
  end;

  VA := VarArrayCreate([1, 6, 1, 7], varVariant);
  mnPartArrayToVADim2(VarArr, VA, 3, 6);
  CheckEquals(VarArrayDimCount(VA), 2);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 6);
  CheckEquals(VarArrayLowBound(VA, 2), 1);
  CheckEquals(VarArrayHighBound(VA, 2), 7);
  Check(VarArrayGet(VA, [3, 6]) = Var_0);
  Check(VarArrayGet(VA, [3, 7]) = Var_1);
  Check(VarArrayGet(VA, [4, 6]) = Var_2);
  Check(VarArrayGet(VA, [4, 7]) = Var_3);
  Check(VarArrayGet(VA, [5, 6]) = Var_4);
  Check(VarArrayGet(VA, [5, 7]) = Var_0);
  Check(VarArrayGet(VA, [6, 6]) = Var_1);
  Check(VarArrayGet(VA, [6, 7]) = Var_2);

  // mnPartArrayToVADim2 overload form 2
  SetLength(StrArr, 4, 2);
  StrArr[0][0] := Str_0;
  StrArr[0][1] := Str_1;
  StrArr[1][0] := Str_2;
  StrArr[1][1] := Str_3;
  StrArr[2][0] := Str_4;
  StrArr[2][1] := Str_0;
  StrArr[3][0] := Str_1;
  StrArr[3][1] := Str_2;

  VA := VarArrayCreate([1, 6, 1, 7], varVariant);
  mnPartArrayToVADim2(StrArr, VA, 3, 6);
  CheckEquals(VarArrayDimCount(VA), 2);
  CheckEquals(VarArrayLowBound(VA, 1), 1);
  CheckEquals(VarArrayHighBound(VA, 1), 6);
  CheckEquals(VarArrayLowBound(VA, 2), 1);
  CheckEquals(VarArrayHighBound(VA, 2), 7);
  Check(VarArrayGet(VA, [3, 6]) = Str_0);
  Check(VarArrayGet(VA, [3, 7]) = Str_1);
  Check(VarArrayGet(VA, [4, 6]) = Str_2);
  Check(VarArrayGet(VA, [4, 7]) = Str_3);
  Check(VarArrayGet(VA, [5, 6]) = Str_4);
  Check(VarArrayGet(VA, [5, 7]) = Str_0);
  Check(VarArrayGet(VA, [6, 6]) = Str_1);
  Check(VarArrayGet(VA, [6, 7]) = Str_2);

  // overload form 3 is ignored
end;

procedure TmnArrayTestCase.testBase1VAToArrayDim2;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
begin
  // mnBase1VAToArrayDim2 overload form 1
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);
  VarArrayPut(VA, Var_0, [2, 8]);
  VarArrayPut(VA, Var_1, [2, 9]);
  VarArrayPut(VA, Var_2, [3, 8]);
  VarArrayPut(VA, Var_3, [3, 9]);
  VarArrayPut(VA, Var_4, [4, 8]);
  VarArrayPut(VA, Var_0, [4, 9]);
  VarArrayPut(VA, Var_1, [5, 8]);
  VarArrayPut(VA, Var_2, [5, 9]);

  SetLength(VarArr, 3);
  mnBase1VAToArrayDim2(VA, VarArr, 4, 8, 9);
  Check(VarArr[0] = Var_4);
  Check(VarArr[1] = Var_0);
  Check(VarArr[2] = Unassigned);

  // mnBase1VAToArrayDim2 overload form 2
  SetLength(StrArr, 3);
  mnBase1VAToArrayDim2(VA, StrArr, 4, 8, 9);
  Check(StrArr[0] = VarToStr(Var_4));
  Check(StrArr[1] = VarToStr(Var_0));
  Check(StrArr[2] = '');

  // overload form 3, 4, 5 and 6 are ignored
end;

procedure TmnArrayTestCase.testBase2VAToArrayDim2;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
begin
  // mnBase2VAToArrayDim2 overload form 1
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);
  VarArrayPut(VA, Var_0, [2, 8]);
  VarArrayPut(VA, Var_1, [2, 9]);
  VarArrayPut(VA, Var_2, [3, 8]);
  VarArrayPut(VA, Var_3, [3, 9]);
  VarArrayPut(VA, Var_4, [4, 8]);
  VarArrayPut(VA, Var_0, [4, 9]);
  VarArrayPut(VA, Var_1, [5, 8]);
  VarArrayPut(VA, Var_2, [5, 9]);

  SetLength(VarArr, 3);
  mnBase2VAToArrayDim2(VA, VarArr, 3, 4, 8);
  Check(VarArr[0] = Var_2);
  Check(VarArr[1] = Var_4);
  Check(VarArr[2] = Unassigned);

  // mnBase2VAToArrayDim2 overload form 2
  SetLength(StrArr, 3);
  mnBase2VAToArrayDim2(VA, StrArr, 3, 4, 8);
  Check(StrArr[0] = VarToStr(Var_2));
  Check(StrArr[1] = VarToStr(Var_4));
  Check(StrArr[2] = '');

  // overload form 3, 4, 5 and 6 are ignored
end;

procedure TmnArrayTestCase.testBase1ArrayToVADim2;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
begin
  // mnBase1ArrayToVADim2 overload form 1
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);

  SetLength(VarArr, 2);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  mnBase1ArrayToVADim2(VarArr, VA, 3, 8);

  Check(VarArrayGet(VA, [3, 8]) = Var_0);
  Check(VarArrayGet(VA, [3, 9]) = Var_1);

  // mnBase1ArrayToVADim2 overload form 2
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);

  SetLength(StrArr, 2);
  StrArr[0] := Str_0;
  StrArr[1] := Str_1;
  mnBase1ArrayToVADim2(StrArr, VA, 3, 8);

  Check(VarArrayGet(VA, [3, 8]) = Str_0);
  Check(VarArrayGet(VA, [3, 9]) = Str_1);

  // overload form 3, 4, 5 and 6 are ignored
end;

procedure TmnArrayTestCase.testBase2ArrayToVADim2;
var
  VA: Variant;
  VarArr: array of Variant;
  StrArr: array of string;
begin
  // mnBase2ArrayToVADim2 overload form 1
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);

  SetLength(VarArr, 3);
  VarArr[0] := Var_0;
  VarArr[1] := Var_1;
  VarArr[2] := Var_2;
  mnBase2ArrayToVADim2(VarArr, VA, 2, 8);

  Check(VarArrayGet(VA, [2, 8]) = Var_0);
  Check(VarArrayGet(VA, [3, 8]) = Var_1);
  Check(VarArrayGet(VA, [4, 8]) = Var_2);

  // mnBase2ArrayToVADim2 overload form 2
  VA := VarArrayCreate([2, 5, 8, 9], varVariant);

  SetLength(StrArr, 3);
  StrArr[0] := Str_0;
  StrArr[1] := Str_1;
  StrArr[2] := Str_2;
  mnBase2ArrayToVADim2(StrArr, VA, 2, 8);

  Check(VarArrayGet(VA, [2, 8]) = Str_0);
  Check(VarArrayGet(VA, [3, 8]) = Str_1);
  Check(VarArrayGet(VA, [4, 8]) = Str_2);

  // overload form 3, 4, 5 and 6 are ignored
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TmnArrayTestCase.Suite);
end.


